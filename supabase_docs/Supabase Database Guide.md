Supabase Database Guide (Resumo de todas as páginas)

Aviso: Esta síntese reúne, em português, informações práticas sobre cada seção da documentação de Banco de Dados da Supabase.  Foram removidos metadados, navegação e instruções de contribuição.  O objetivo é compilar o conhecimento essencial para consultas rápidas em sistemas de recuperação de informação (RAG).  Para detalhes completos de código, exemplos ou descrições extensas, consulte a documentação original da Supabase.

1. Fundamentos

1.1 Conectando‑se ao banco de dados
	•	Métodos de conexão: A Supabase oferece diversas maneiras de conectar seu aplicativo ao banco Postgres.  Para aplicações frontend, recomenda‑se usar a Data API (REST ou GraphQL).  Para clientes Postgres tradicionais (psql, pgAdmin, etc.), utilize a string de conexão.  Dependendo do ambiente:
	•	Conexão direta: Ideal para servidores persistentes e contêineres de longa duração que suportem IPv6.  A string de conexão segue o padrão postgresql://postgres:[SENHA]@db.[ID_PROJETO].supabase.co:5432/postgres.
	•	Supavisor (modo sessão): Acessa o banco por meio de um proxy que oferece suporte a IPv4/IPv6; adequado para ambientes que não suportam IPv6.
	•	Supavisor (modo transação): Usa um proxy e um pool de conexões; indicado para funções serverless ou edge que abrem muitas conexões temporárias.
	•	Pooler compartilhado e dedicado: Todo projeto possui um pooler compartilhado gratuito; clientes pagos podem habilitar um pooler dedicado (PgBouncer) para otimizar latência e desempenho.
	•	Pooling de conexões: Poolers do lado do aplicativo (ex.: Prisma, SQLAlchemy) ou do lado do servidor (Supavisor) reaproveitam conexões para reduzir sobrecarga.  Use poolers para aplicações auto‑escaláveis ou serverless.
	•	SSL: Sempre conecte com SSL para evitar interceptação.  As informações de conexão e certificado raiz estão no painel do projeto.
	•	Troubleshooting: Erros comuns incluem “Connection refused” (banco offline ou firewall) e “FATAL: Password authentication failed” (usuário ou senha incorretos).  Para conexão via IPv4, utilize Supavisor.  Escolha o método de conexão conforme seu tipo de aplicação (direto, sessão, transação, compartilhado ou dedicado).

1.2 Importando dados
	•	Opções para importação:
	1.	CSV via painel: Indicado para conjuntos de dados pequenos (até ~100 MB).  Acesse o editor de tabelas, escolha Importar CSV e siga as instruções.
	2.	pgloader: Ferramenta eficiente para importar grandes volumes de dados de diversos bancos de origem (MySQL, MS SQL, etc.).  Crie um arquivo de configuração indicando o banco fonte e o destino no Supabase e execute pgloader config.load.
	3.	Comando PostgreSQL COPY: Para cargas grandes no formato CSV/TSV, use o comando COPY para carregar diretamente do arquivo para a tabela.
	4.	API Supabase: Permite automatizar a inserção de dados programaticamente.  Útil para sincronizações e integrações contínuas; evite importações em massa por API devido ao limite de taxa.
	•	Preparação para importar: Faça backup do banco, aumente o tempo limite das consultas se necessário, estime o espaço em disco, desative triggers temporariamente (por exemplo, ALTER TABLE my_table DISABLE TRIGGER ALL e reative depois) e reconstrua índices após a carga para melhorar performance.

1.3 Segurança de dados
	•	Políticas de acesso: Ative o Row Level Security (RLS) nas tabelas e defina políticas para controlar o acesso aos registros.  O RLS garante que o usuário só veja dados permitidos.
	•	Uso da API de dados: Para aplicações frontend, use a Data API com RLS habilitado.  Utilize a anon key para inicializar o cliente; ela é segura para o frontend porque as permissões são avaliadas no banco.  Nunca exponha a service role key no frontend; essa chave contorna o RLS e deve ficar restrita ao backend.
	•	Mais recursos: Consulte as páginas de acesso e segurança para detalhes sobre RLS, segurança por coluna, reforço da API de dados, funções RBAC, gestão de roles no Postgres e armazenamento de segredos (Vault).

2. Trabalhando com o banco (básico)

2.1 Gerenciamento de tabelas, colunas e dados
	•	Criação de tabelas: Defina colunas com tipos apropriados no momento da criação.  Um design cuidadoso simplifica consultas e integridade referencial.  Para cada tabela, escolha uma chave primária (tipicamente uma coluna serial ou bigint com generated by default as identity).
	•	Tipos de dados: Postgres oferece uma variedade de tipos (inteiros, texto, booleanos, datas, etc.) e permite definir tipos personalizados ou instalar extensões para tipos adicionais.
	•	Carregamento de dados: Insira registros diretamente pelo dashboard, use scripts SQL ou a API.  Para grandes volumes, utilize o comando COPY ou ferramentas como pgloader (ver seção de importação).
	•	Joins: Utilize chaves estrangeiras para relacionar tabelas.  Para consultas one‑to‑many, a API detecta automaticamente os relacionamentos.  Para many‑to‑many, crie uma tabela de junção (por exemplo, members com user_id e team_id).  Para joins com várias chaves estrangeiras no mesmo destino, especifique manualmente a cláusula ON na consulta.
	•	Schemas: Organize suas tabelas em esquemas para melhor organização e segurança.  Schemas permitem separar tabelas por domínio ou área de negócio.
	•	Views: Uma view é uma consulta salva que retorna dados como se fosse uma tabela.  Use views para simplificar consultas repetitivas, garantir consistência, organizar logicamente e restringir acesso.  Views materializadas armazenam os resultados em disco para aumentar a velocidade de leitura, porém precisam ser atualizadas (REFRESH) periodicamente.
	•	Segurança das views: Por padrão, as views são executadas com as permissões de quem as criou (security definer).  Avalie a segurança ao criar views que acessam dados sensíveis.

2.2 Trabalhando com arrays
	•	Criação de coluna array: Ao criar uma tabela, defina uma coluna com o tipo base e marque como array (por exemplo, text[]).  No dashboard: clique em Nova coluna, informe o nome, selecione o tipo e marque Definir como array.
	•	Inserção de valores: Insira registros contendo arrays, por exemplo ['Harry','Larry','Moe'].  Use o Table Editor ou a API.
	•	Consulta de arrays: Postgres usa indexação base 1 (textarray[1]).  Para pegar o primeiro elemento e o tamanho, execute:
	SELECT textarray[1], array_length(textarray, 1)
FROM arraytest;
	•	Consulte a documentação do Postgres para operações avançadas de arrays e funções associadas.

2.3 Gerenciando índices
	•	Criação de índices: Use CREATE INDEX nome_do_indice ON tabela (coluna); para acelerar consultas.  Para evitar bloqueio em tabelas grandes, utilize CREATE INDEX CONCURRENTLY.
	•	Índices parciais: Úteis quando as consultas filtram apenas um subconjunto (ex.: WHERE deceased IS false).  Exemplo: CREATE INDEX idx_alive ON persons (age) WHERE deceased IS false;.
	•	Ordenação personalizada: Para ordenar em ordem decrescente ou tratar NULLs ao final: CREATE INDEX idx_age_desc ON persons (age DESC NULLS LAST);.
	•	Reindexação: Com o tempo, índices podem ficar fragmentados.  Use REINDEX para reconstruí‑los, preferindo REINDEX ... CONCURRENTLY para evitar bloqueios.
	•	Index Advisor: O painel da Supabase possui um Index Advisor que sugere índices com base nas consultas observadas.  Revise as recomendações e crie índices quando trazem benefício.  Nem toda recomendação precisa ser aplicada; o otimizador do Postgres decide quando usar ou ignorar um índice.

2.4 Joins e consultas aninhadas
	•	One‑to‑many: Ao selecionar dados de tabelas com chave estrangeira, use a sintaxe de seleção aninhada na API (select('id, name, instruments (id, name)')).  A API detecta relacionamentos com base nas chaves estrangeiras.
	•	Many‑to‑many: Crie uma tabela intermediária (join table) e a API infere automaticamente o relacionamento ao aninhar as tabelas.
	•	Joins com múltiplas chaves estrangeiras: Quando uma tabela referencia a mesma tabela várias vezes (ex.: shifts com scan_id_start e scan_id_end apontando para scans), especifique a cláusula ON explicitamente para evitar ambiguidade.

2.5 JSON e dados não estruturados
	•	Tipos json e jsonb: json armazena texto literal; jsonb armazena representação binária e é recomendado na maioria dos casos por oferecer buscas mais rápidas.  A diferença principal é a forma de armazenamento e performance de consulta.
	•	Quando usar: Utilize colunas JSONB para dados com estrutura flexível, como cargas de webhooks ou propriedades dinâmicas.  Não exagere: aproveite a modelagem relacional sempre que possível para manter integridade referencial e desempenho nas consultas.
	•	Criação de colunas: Crie colunas jsonb como qualquer outro tipo: metadata jsonb.
	•	Inserção: Insira objetos JSON válidos.  Exemplo:INSERT INTO books (title, author, metadata)
VALUES ('The Poky Little Puppy', 'Janette Lowrey', '{"description":"...","price":5.95,"ages":[3,6]}');
	•	Consulta: Use operadores -> (retorna jsonb) e ->> (retorna text) para acessar campos aninhados.  Exemplo:
	SELECT title,
       metadata ->> 'description' AS description,
       metadata -> 'price'        AS price,
       metadata -> 'ages' -> 0    AS low_age,
       metadata -> 'ages' -> 1    AS high_age
FROM books;
	•	Validação: Ative a extensão pg_jsonschema para validar JSON contra um schema JSON.  Depois adicione uma check constraint que chama json_matches_schema() para assegurar que os dados obedecem ao esquema.

3. Trabalhando com o banco (intermediário)

3.1 Exclusões em cascata
	•	Ao definir chaves estrangeiras, você pode escolher a ação ao excluir linhas da tabela pai:
	•	ON DELETE CASCADE: remove automaticamente linhas filhas quando a linha pai é excluída.
	•	ON DELETE RESTRICT ou NO ACTION: bloqueia a exclusão se existirem registros relacionados.  A diferença entre RESTRICT e NO ACTION é sutil — NO ACTION só gera erro no final da transação, enquanto RESTRICT impede a ação imediatamente.
	•	Exemplo:  Se houver uma tabela orders com order_items, definir ON DELETE CASCADE na chave estrangeira de order_items.order_id faz com que todos os itens do pedido sejam removidos quando o pedido for deletado.

3.2 Enums
	•	Postgres permite criar tipos enumerados para valores finitos (ex.: status).  Crie um enum com CREATE TYPE status AS ENUM ('pending','shipped','delivered'); e use‑o como tipo de coluna.
	•	Para adicionar ou remover valores de um enum existente, use ALTER TYPE status ADD VALUE 'cancelled'; (não é possível remover valores sem recriar o tipo).

3.3 Funções e stored procedures
	•	Você pode criar funções SQL ou procedures PL/pgSQL para encapsular lógica.  Use CREATE FUNCTION para funções que retornam valores e podem ser usadas em consultas; use CREATE PROCEDURE para procedimentos que executam operações e devem ser chamadas com CALL.
	•	Funções podem ser marcadas como IMMUTABLE, STABLE ou VOLATILE para otimizar o planejamento de queries.  Conceda permissões de execução com GRANT EXECUTE ON FUNCTION.

3.4 Triggers
	•	Triggers executam funções automaticamente em resposta a eventos (INSERT, UPDATE, DELETE).  Crie uma função de trigger e depois associe‑a a uma tabela usando CREATE TRIGGER.  Exemplo: auditar alterações em uma tabela gravando inserções em uma tabela de log.

3.5 Webhooks
	•	Supabase oferece Webhooks para notificações de mudanças no banco.  Você pode configurar triggers que chamam uma URL externa (por exemplo, via http extension) para notificar serviços externos quando dados são inseridos, atualizados ou excluídos.

3.6 Full Text Search
	•	Utilize colunas do tipo tsvector para indexar textos e funções como to_tsvector e to_tsquery para gerar índices e consultas.  Ative a extensão pgroonga ou rum para pesquisas multilíngues ou otimizações adicionais.

3.7 Particionamento de tabelas
	•	O particionamento divide uma tabela grande em partes menores para melhorar desempenho e gerenciamento.  Postgres suporta particionamento por range, list ou hash.  Defina uma tabela pai sem dados e crie filhas com PARTITION OF ... especificando as regras de particionamento.

3.8 Gerenciando conexões
	•	Monitore o número de conexões ativas ao banco e utilize poolers (como Supavisor) para compartilhar conexões entre processos.  Ajuste parâmetros como max_connections e statement_timeout via painel.

4. OrioleDB
	•	Index‑organized tables: OrioleDB armazena os dados diretamente na estrutura de índice, eliminando a separação entre heap e índice e melhorando buscas por chave primária.
	•	Sem buffer mapping: Ligações diretas entre páginas em memória e armazenamento evitam a complexidade do buffer pool do Postgres.
	•	Undo log: Implementa MVCC através de um log de desfazer, armazenando versões antigas das linhas e informações de transação.  Isso elimina a necessidade de vacuum.
	•	Copy‑on‑write checkpoints: Apenas páginas modificadas são gravadas em disco durante checkpoints, reduzindo I/O.
	•	Uso: Para testar OrioleDB, crie um novo projeto no painel e selecione a versão “OrioleDB Public Alpha”.  As instruções de criação de tabelas são semelhantes às do Postgres.  Todas as tabelas devem ter chave primária (caso contrário, é criada automaticamente).  Até o momento, apenas índices B‑tree são suportados.

5. Acesso e segurança
	•	Row Level Security (RLS): Controle o acesso a linhas específicas com políticas que avaliam o usuário (via JWT) e outras condições.  Habilite RLS por tabela e escreva regras POLICY para permitir ou negar operações.
	•	Column Level Security: Restringe a leitura ou escrita em colunas específicas.  Útil quando diferentes usuários podem ver apenas determinados campos.
	•	Hardening da API de dados: Configure limites de taxa, defina filtros de entrada e proteja endpoints da API para evitar abusos.
	•	Custom Claims & RBAC: Adicione claims personalizados no token JWT para representar papéis (roles) ou permissões extras e use‑as nas políticas RLS.  Combine com RBAC (Roles Based Access Control) para gestão de privilégios.
	•	Gerenciamento de papéis (roles): Crie e atribua roles no Postgres para controlar permissões globais.  Use CREATE ROLE, GRANT e REVOKE para ajustar privilégios.  Roles personalizadas podem ser usadas em conexões de banco para permitir acesso específico.
	•	Gerenciamento de segredos com Vault: Integre o HashiCorp Vault para armazenar chaves e segredos de forma segura.  O Vault permite rotação de credenciais e políticas de acesso.
	•	Superuser e operações não suportadas: Projetos Supabase não permitem acesso superuser nem certas operações administrativas (por exemplo, pg_terminate_backend).  Consulte a página de restrições para saber o que está desabilitado.

6. Configuração, otimização e testes
	•	Configuração do banco: Ajuste parâmetros (como log_min_duration_statement, work_mem, maintenance_work_mem) através do painel ou via instruções ALTER SYSTEM.  Esses ajustes afetam desempenho de queries, uso de memória e logs.
	•	Otimização de consultas: Use EXPLAIN para analisar planos de execução.  Crie índices apropriados, evite consultas não seletivas e refatore queries que realizam varreduras completas de tabelas grandes.
	•	Database Advisors: O painel Supabase oferece conselhos automáticos de otimização (índices, parâmetros) baseados no histórico de consultas.
	•	Testes: Utilize ambientes de staging para testar alterações no esquema, políticas de segurança e consultas antes de promover para produção.  Ferramentas como pgTAP permitem criar testes unitários para funções e triggers.
	•	Customização de configuração: Para ajustes mais avançados, edite o arquivo postgresql.conf via painel (dependendo do plano) ou configure parâmetros na inicialização do contêiner.

7. Depuração e monitoramento
	•	Timeouts: Ajuste statement_timeout para evitar queries longas que bloqueiam o sistema.  Para operações de importação ou manutenção que precisam de mais tempo, aumente temporariamente o valor.
	•	Debugging e monitoramento: Use ferramentas de monitoramento (como Query Performance e Logs no painel) para examinar consultas lentas, índices usados e consumo de CPU/memória.  Ative logs detalhados (log_statement) para depurar instruções.
	•	Performance issues: Para investigar problemas de performance, verifique lock contention, uso de índices, estatísticas de vacuum/analyze e verifique se há bloat de tabelas ou índices.
	•	Supavisor: Serviço de pooling de conexões da Supabase que gerencia conexões persistentes e temporárias.  O Supavisor monitora, distribui e otimiza conexões para impedir que picos de uso sobrecarreguem o banco.
	•	Troubleshooting: A seção de troubleshooting aborda problemas comuns (erros de autenticação, limites de conexão, tempo‑out, etc.) e sugere soluções (verificar configurações, ajustar poolers, redes).

8. ORM Quickstarts (guia rápido)

A Supabase fornece tutoriais rápidos para integrar ORMs populares:
	•	Prisma: Instale a biblioteca @prisma/client e configure o datasource em schema.prisma com a string de conexão Supabase.  Execute npx prisma db pull para gerar o esquema e use o cliente Prisma para consultar e mutar dados.
	•	Drizzle: Configure o Drizzle ORM com a URL de conexão e defina tabelas e modelos usando as funções do Drizzle.  Utilize a API do Drizzle para executar queries tipadas.
	•	Postgres.js: Biblioteca de consulta em JavaScript com suporte a templates tag SQL.  Inicialize o cliente com a string de conexão Supabase e escreva consultas com sql\…``.  Suporta pool de conexões e prepared statements.

9. GUI Quickstarts
	•	pgAdmin: Ferramenta gráfica para gerenciar Postgres.  Adicione um novo servidor com a string de conexão Supabase e acesse tabelas, esquemas, funções e dados.
	•	PSQL: O cliente de linha de comando nativo do Postgres.  Conecte com psql "sua_string_de_conexao" e execute comandos SQL interativamente.
	•	DBeaver: IDE universal para bancos de dados.  Crie uma nova conexão do tipo PostgreSQL e insira os dados de acesso Supabase.
	•	Metabase: Plataforma de visualização de dados.  Configure uma nova fonte de dados PostgreSQL apontando para a URL do projeto e crie dashboards sobre suas tabelas.
	•	Beekeeper Studio: Cliente SQL multiplataforma; configure a conexão PostgreSQL com o host, porta, banco e credenciais fornecidas pela Supabase.

10. Replicação de banco de dados
	•	Visão geral: Supabase permite replicar dados do seu banco para um Postgres externo (Logical Replication).  Isso pode ser usado para cópias de leitura, integrações analíticas ou migrações.
	•	Configuração: Ative a replicação no painel, crie publication para as tabelas desejadas e configure um subscription no banco de destino usando CREATE SUBSCRIPTION ... CONNECTION ... PUBLICATION ....
	•	Monitoramento: Acompanhe o atraso de replicação e status das assinaturas pelo painel.  Certifique‑se de que o banco de destino esteja configurado com o mesmo ou compatível collation e extensão.
	•	FAQ: A seção de perguntas frequentes aborda limitações (por exemplo, replicação de extensões e tabelas temporárias) e boas práticas.

11. Extensões (resumo)

Supabase suporta uma série de extensões PostgreSQL que adicionam recursos.  Algumas delas:
	•	HypoPG: Cria índices hipotéticos para estimar impacto no plano de execução sem criar o índice real.
	•	plv8: Permite escrever funções em JavaScript (deprecated no Supabase).  Evite para novos projetos.
	•	http: Cliente HTTP dentro do banco, permite fazer requisições REST de dentro de funções SQL/PLpgSQL.
	•	index_advisor: Sugere índices baseados em consultas capturadas (integrado ao Index Advisor do painel).
	•	PGAudit: Fornece auditoria detalhada de comandos SQL.
	•	PGroonga: Indexação e busca full‑text multilíngue.
	•	pgRouting: Funções para roteamento e grafos geográficos (extensão do PostGIS).
	•	pg_cron: Agendamento de tarefas recorrentes diretamente no banco (similar ao cron do Unix).
	•	pg_graphql: Implementa um endpoint GraphQL diretamente no Postgres.
	•	pg_hashids: Gera identificadores curtos usando Hashids.
	•	pg_jsonschema: Permite validar dados JSON/JSONB contra schemas JSON.
	•	pg_net: Networking assíncrono; permite chamadas HTTP/TCP sem bloquear a transação.
	•	pg_plan_filter: Permite restringir o custo total de planos de consulta.
	•	postgres_fdw: Permite consultar dados de outro servidor Postgres como se fosse uma tabela local.
	•	pgvector: Suporte a embeddings e busca vetorial (ideal para aplicações de IA).
	•	pg_stat_statements: Coleta estatísticas de execução de consultas (tempo, contagem, etc.).
	•	pg_repack: Reorganiza tabelas e índices para reduzir desperdício de espaço (sem lock abrangente).
	•	PostGIS: Adiciona tipos e funções geoespaciais para consultas GIS.
	•	pgmq: Implementa filas de mensagens internas.
	•	pgsodium: (em descontinuação) Suporte a criptografia no banco.
	•	pgTAP: Framework de testes unitários para funções PL/pgSQL.
	•	plpgsql_check: Linter para código PL/pgSQL.
	•	timescaledb: Banco de dados temporal (deprecated no Supabase).  Usa compressão e partições para séries temporais.
	•	uuid‑ossp: Gera UUIDs (versões 1, 4, etc.).
	•	RUM: Índice invertido para busca full‑text e similaridade (alternativa ao GIN/GiST).

12. Foreign Data Wrappers (FDW)
	•	O Supabase oferece guias para conectar o Postgres a serviços externos através de FDWs.  Isso inclui integrações com Auth0, Airtable, AWS Cognito, AWS S3, BigQuery, Clerk, ClickHouse, DuckDB, Firebase, Iceberg, Logflare, MSSQL, Notion, Paddle, Redis, Snowflake, Stripe e outros.
	•	Cada guia geralmente consiste em instalar a extensão (por exemplo, CREATE EXTENSION postgres_fdw; ou o FDW específico), criar um server apontando para a fonte, definir usuários e senhas, e criar foreign tables que espelham as tabelas externas.  Após configurado, você pode consultar dados remotos com SQL nativo.

13. Exemplos
	•	Drop All Tables in Schema: Script SQL que itera sobre tabelas em um schema e remove todas com DROP TABLE.
	•	Select First Row per Group: Consulta que usa DISTINCT ON ou ROW_NUMBER() para pegar o primeiro registro de cada grupo.
	•	Print PostgreSQL Version: Usa SELECT version(); para exibir a versão atual do banco.
	•	Replicating from Supabase to External Postgres: Demonstra como configurar publication e subscription para replicar dados do Supabase para outro servidor.